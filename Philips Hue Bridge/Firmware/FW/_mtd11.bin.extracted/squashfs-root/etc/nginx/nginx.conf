user nobody nogroup;




worker_processes 1;

events {
	worker_connections 50;
}

http {
	nchan_shared_memory_size 900k;
	
	

	include mime.types;

	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;

	root "/www";

	# disable access log, and send errors to syslog
	access_log off;
	error_log syslog:server=unix:/dev/log;

	# hide nginx version number
	server_tokens off;
	proxy_hide_header X-Powered-By;
	proxy_hide_header Server;

	# disable proxy buffering to keep behavior as close as possible to original ipbridge
	proxy_buffering off;
	proxy_request_buffering off;

	reset_timedout_connection on;
	client_header_timeout 10s;
	client_body_timeout 10s;
	send_timeout 10s;
	lingering_timeout 2s;
	lingering_time 10s;

	limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:32k;
	# To only allow one connection to the /updater endpoint, regardless of IP.
	limit_conn_zone $request_uri zone=conn_limit_updater:32k;
	limit_conn_status 429;
	limit_req_zone $connection zone=req_limit_per_connection:128k rate=25r/s;
	limit_req_status 429;

	proxy_set_header request-origin "local";

	upstream ipbridge {
		server 127.0.0.1:9001;
	}

	upstream ipbridge_migration {
		server 127.0.0.1:55556;
	}

	upstream migration {
		server 127.0.0.1:55557;
	}

	upstream clipd {
		server 127.0.0.1:9003;
	}

	upstream eventing {
		server 127.0.0.1:8083;
	}

	upstream entertainmentd {
		server 127.0.0.1:9004;
	}

	upstream updated {
		server 127.0.0.1:9999;
	}

	server {
		keepalive_timeout 0s;
		listen 80;
		listen [::]:80;

		# force a disconnect on 502 error, to emulate old behavior when bridge application is NOT (yet) running
		error_page 502 =444 /444-response;

		location = /444-response {
			internal;
			return 444;
		}

		# Ensure hidden file serving is disabled
		location ~ /\. {
			internal;
			return 404;
		}

		# enables the Cross-site scripting (XSS) filter
    add_header X-XSS-Protection "1; mode=block";

    # enable clickjacking protection
    add_header X-Frame-Options "SAMEORIGIN";

    # disable content-type sniffing
    add_header X-Content-Type-Options nosniff;

    # Restrict to http content from bridge webserver only
    add_header Content-Security-Policy "default-src 'self'";

    # Prevent cacheable SSL pages
    add_header Cache-Control no-store;
    add_header Pragma no-cache;
    
    # set referrer policy
    add_header Referrer-Policy "no-referrer";

		chunked_transfer_encoding off;
		set $request_origin "local";
		proxy_set_header request-origin $request_origin;
		include apiv1.legacy.conf;
		include updater.conf;
	}

	server {
		listen 3245;

		keepalive_timeout 24h;
		keepalive_requests 10000;

		proxy_http_version 1.1;
		proxy_set_header Connection "";

		set $request_origin "remote";
		proxy_set_header request-origin $request_origin;

		# enables the Cross-site scripting (XSS) filter
    add_header X-XSS-Protection "1; mode=block";

    # enable clickjacking protection
    add_header X-Frame-Options "SAMEORIGIN";

    # disable content-type sniffing
    add_header X-Content-Type-Options nosniff;

    # Restrict to http content from bridge webserver only
    add_header Content-Security-Policy "default-src 'self'";

    # Prevent cacheable SSL pages
    add_header Cache-Control no-store;
    add_header Pragma no-cache;
    
    # set referrer policy
    add_header Referrer-Policy "no-referrer";

		include apiv1.new.conf;
		include auth.conf;
		include clipv2.conf;
		include entertainment.conf;
		include updater.conf;
		include migrationv1.conf;
		include migrationv2.conf;
	}

	include https-endpoints.conf;

	server {
		keepalive_timeout 24h;
		client_body_buffer_size 512k;

		listen 8083;
		listen [::]:8083;

		chunked_transfer_encoding off;

		include eventing.conf;
	}

	server {
		listen 9815;
		resolver 127.0.0.1;

		proxy_ssl_trusted_certificate /etc/ssl/certs/data.meethue.com/ca.crt;
		proxy_ssl_verify on;

		location / {
			proxy_pass $http_x_forwarded_to;
		}
	}

	server {
		listen 7584;

		keepalive_timeout 15;
		keepalive_requests 1000;

		proxy_http_version 1.1;
		proxy_set_header Connection "";

		# ClipV1 auth is handled by IP bridge. By passing the "internal"
		# header, IpBridge will give GEN_CLIP_ACCESSLEVEL_INTERNAL to the call.
		set $request_origin "internal";
		proxy_set_header request-origin $request_origin;

		# ClipV2 expects an auth endpoint. Since the request comes from the bridge itself,
		# that is not needed.
		location = /auth {
			internal;
			return 200;
		}

		include apiv1.new.conf;
		include clipv2.conf;
	}
}
